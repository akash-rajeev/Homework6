#'
#' @slot value nonzero values vector
#' @slot pos nonzero value positions vector
#' @slot length integer representing length of vector
#'
#' @export
setClass(
Class = "sparse_numeric",
slots = c(
value = "numeric",
pos = "integer",
length = "integer"
)
)
# Validity Function
setValidity("sparse_numeric", function(object) {
# Check if value and pos same length
if (length(object@value) != length(object@pos)) {
return("@value and @pos must be same length")
}
# Check that length is valid
if (object@length < 0 | length(object@length) != 1){
return("@length must be greater than 0 and be a single value")
}
# Check that all positions are valid
if (any(object@pos < 1)  || any(object@pos > object@length) ){
return("positions are either less than 0 or greater than length of vector")
}
# Check that position values are unique
if (length(unique(object@pos)) != length(object@pos)){
return("position values are not unique")
}
# Check that all values in value are nonzero
if (any(object@value == 0)){return("not all values in @value are nonzero")}
# Check that matrix is sorted
if (is.unsorted(object@pos)) {return("not sorted")}
TRUE
})
# Addition Function
#' Add Two Sparse Numeric Vectors
#'
#' Adds two sparse vectors
#'
#' @param x A sparse_numeric object
#' @param y A sparse_numeric object
#' @param ... Additional arguments, not used
#' @return sparse_numeric object containing sum
#' @export
#' @examples
#' x <- as(c(0, 5, 0, -3), "sparse_numeric")
#' y <- as(c(1, 0, 0, -3), "sparse_numeric")
#' sparse_add(x, y)
setGeneric("sparse_add", function(x, y, ...) standardGeneric("sparse_add"))
#' @rdname sparse_add
#' @export
setMethod("sparse_add", c("sparse_numeric", "sparse_numeric"), function(x, y, ...){
# check that x and y have same length
if (x@length != y@length){stop("vectors are not same length")}
# find what positions to look at
all_pos_add = sort(unique(c(x@pos, y@pos)))
# calculate the sum at each position
all_sums = c()
all_positions_add = c()
for (pos in all_pos_add){
val = 0
if (pos %in% x@pos){
idx = which(x@pos == pos)
val = val + x@value[idx]
}
if (pos %in% y@pos){
idx = which(y@pos == pos)
val = val + y@value[idx]
}
if (val != 0){
all_sums = c(all_sums, val)
all_positions_add = c(all_positions_add, pos)
}
}
if(length(all_sums) == 0){
all_sums = numeric(0)
all_positions_add = integer(0)
}
# check if results have same length
if(length(all_sums) != length(all_positions_add)){stop("result vectors not same length")}
return(new("sparse_numeric", value = all_sums, pos = all_positions_add, length = x@length))
})
# Multiplication Function
#' Multiply Two Sparse Numeric Vectors
#'
#' multiplication of two sparse vectors
#'
#' @param x A sparse_numeric object
#' @param y A sparse_numeric object
#' @param ... Additional arguments, not used
#' @return sparse_numeric object containing product
#' @export
#' @examples
#' x <- as(c(0, 5, 0, -3), "sparse_numeric")
#' y <- as(c(1, 0, 2, -3), "sparse_numeric")
#' sparse_mult(x, y)
setGeneric("sparse_mult", function(x, y, ...) standardGeneric("sparse_mult"))
#' @rdname sparse_mult
#' @export
setMethod("sparse_mult", c("sparse_numeric", "sparse_numeric"), function(x, y, ...) {
# check x y same length
if (x@length != y@length){stop("vectors are not same length")}
# find what positions to look at (common non-zero positions)
all_pos_mult = intersect(x@pos, y@pos)
product_vals = c()
product_pos = c()
for (pos in all_pos_mult){
# get x value
x_idx = which(x@pos == pos)
x_val = x@value[x_idx]
# get y value
y_idx = which(y@pos == pos)
y_val = y@value[y_idx]
# multiply values
product = x_val * y_val
# only keep non-zero
if (product != 0){
product_vals = c(product_vals, product)
product_pos = c(product_pos, pos)
}
}
if(length(product_vals) == 0){
product_vals = numeric(0)
product_pos = integer(0)
}
# check that product vectors have same length
if(length(product_vals) != length(product_pos)){
stop("result vectors not same length")
}
# return new sparse_numeric object
return(new("sparse_numeric", value = product_vals, pos = as.integer(product_pos), length = x@length))
})
# Subtraction Function
#' Subtract Two Sparse Numeric Vectors
#'
#' subtraction of two sparse vector
#'
#' @param x A sparse_numeric object
#' @param y A sparse_numeric object
#' @param ... Additional arguments, not used
#' @return sparse_numeric object containing difference
#' @export
#' @examples
#' x <- as(c(0, 5, 0, -3), "sparse_numeric")
#' y <- as(c(1, 0, 0, -3), "sparse_numeric")
#' sparse_sub(x, y)
setGeneric("sparse_sub", function(x, y, ...) standardGeneric("sparse_sub"))
#' @rdname sparse_sub
#' @export
setMethod("sparse_sub", c("sparse_numeric", "sparse_numeric"), function(x, y, ...) {
# Check x y same length
if (x@length != y@length){stop("vectors are not same length")}
# Find positions where either x or y has value
all_pos_sub = sort(unique(c(x@pos, y@pos)))
# Initialize result vectors
diff_pos = c()
diff_vals = c()
# Loop through all positions
for (pos in all_pos_sub) {
val = 0
if (pos %in% x@pos){
idx = which(x@pos == pos)
val = val + x@value[idx]
}
if (pos %in% y@pos){
idx = which(y@pos == pos)
val = val - y@value[idx]
}
# Save if non-zero
if (val != 0){
diff_vals = c(diff_vals, val)
diff_pos = c(diff_pos, pos)
}
}
if(length(diff_vals) == 0){
diff_vals = numeric(0)
diff_pos = integer(0)
}
# Check if vectors same length
if(length(diff_vals) != length(diff_pos)){
stop("result vectors not same length")
}
# Return new sparse_numeric object
return(new("sparse_numeric", value = diff_vals, pos = as.integer(diff_pos), length = x@length))
})
# Dot Product Function
#' Dot Product/Cross Product (?) of Sparse Numeric Vectors
#'
#' dot product of two sparse numeric vectors.
#'
#' @param x sparse_numeric object
#' @param y sparse_numeric object
#' @param ... Additional arguments, not used
#' @return value representing dot product
#' @export
#' @examples
#' x <- as(c(0, 5, 0, -3), "sparse_numeric")
#' y <- as(c(1, 0, 0, -3), "sparse_numeric")
#' sparse_crossprod(x, y)
setGeneric("sparse_crossprod", function(x, y, ...) standardGeneric("sparse_crossprod"))
#' @rdname sparse_crossprod
#' @export
setMethod("sparse_crossprod", c("sparse_numeric", "sparse_numeric"), function(x, y, ...) {
# Check x y same length
if (x@length != y@length){
stop("vectors are not same length")
}
# Find positions where both have values
common_pos = intersect(x@pos, y@pos)
result = 0
# loop through
for (pos in common_pos) {
x_idx = which(x@pos == pos)
x_val = x@value[x_idx]
y_idx =  which(y@pos == pos)
y_val = y@value[y_idx]
result = result + (x_val * y_val)
}
return(result)
})
# Operator Overloads
#' @rdname sparse_add
#' @export
setMethod("+", c("sparse_numeric", "sparse_numeric"),
function(e1, e2) {
sparse_add(e1, e2)
})
#' @rdname sparse_sub
#' @export
setMethod("-", c("sparse_numeric", "sparse_numeric"),
function(e1, e2){
sparse_sub(e1, e2)
})
#' @rdname sparse_mult
#' @export
setMethod("*", c("sparse_numeric", "sparse_numeric"),
function(e1, e2){
sparse_mult(e1, e2)
})
# coercion methods
#' Convert Numeric Vector to Sparse Numeric Vector
#'
#' @param from A numeric vector
#' @name coerce-numeric-sparse_numeric
setAs("numeric", "sparse_numeric", function(from) {
nz_pos = which(from != 0)
nz_vals = from[nz_pos]
len = as.integer(length(from))
new("sparse_numeric", value = nz_vals, pos = as.integer(nz_pos), length = len)
})
#sparse_numeric -> numeric
#' Convert Sparse Numeric Vector to Numeric Vector
#'
#' @param from A sparse_numeric object
#' @name coerce-sparse_numeric-numeric
setAs("sparse_numeric", "numeric", function(from) {
x = numeric(from@length)
x[from@pos] = from@value
return(x)
})
#Display Methods
# Show method for sparse_numeric
#' Show Method for Sparse Numeric Vectors
#'
#' @param object A sparse_numeric object
#' @export
setMethod("show", "sparse_numeric", function(object) {
cat("Sparse Numeric Vector (length =", object@length, ")\n")
if (length(object@value) == 0) {
cat("Non-zero values: (none)\n")
} else {
cat("Non-zero values:\n")
print(data.frame(position = object@pos, value = object@value))
}
})
# Plot method for sparse_numeric
#' Plot Method for Comparing Two Sparse Numeric Vectors
#'
#' @param x A sparse_numeric object
#' @param y A sparse_numeric object
#' @param ... Additional plotting parameters
#' @export
setMethod("plot", c(x = "sparse_numeric", y = "sparse_numeric"), function(x, y, ...) {
# Determine limits - make sure to extract the integer value
max_len = max(as.numeric(x@length), as.numeric(y@length))
# Get all values for y-axis range - convert to numeric first
all_values = c(as.numeric(x@value), as.numeric(y@value))
if (length(all_values) == 0) {
all_values = c(0, 1)  # Default range if both empty
} else {
all_values = c(all_values, 0)  # Include 0 in range
}
# Create base plot
graphics::plot.default(1, type = "n",
xlim = c(1, max_len), ylim = range(all_values),
xlab = "Position", ylab = "Value", main = "Sparse Vector Comparison")
# Add points if they exist
if (length(x@pos) > 0){
points(as.numeric(x@pos), as.numeric(x@value), col = "blue", pch = 19)
}
if (length(y@pos) > 0){
points(as.numeric(y@pos), as.numeric(y@value), col = "red", pch = 17)
}
legend("topright", legend = c("x", "y"), col = c("blue", "red"), pch = c(19, 17))
})
# Statistical Methods
# sum method
#' Sum of Sparse Numeric Vector
#'
#' @param x sparse_numeric object
#' @param ... Additional arguments passed to sum
#' @export
setMethod("sum", "sparse_numeric", function(x, ...) {
sum(x@value, ...)
})
#' Mean of Sparse Numeric Vector
#'
#' computes mean of sparse numeric vector
#'
#' @name mean
#'
#' @param x A sparse_numeric object
#' @param trim trim value
#' @param na.rm logical, should missing values be removed?
#' @param ... Additional arguments (not used)
#' @return mean of vector
#' @export
#' @examples
#' x <- as(c(0, 5, 0, -3, 0, 0, 10), "sparse_numeric")
#' mean(x)
setGeneric("mean", function(x, ...) standardGeneric("mean"))
#' @rdname mean
#' @export
setMethod("mean", "sparse_numeric", function(x, trim = 0, na.rm = FALSE, ...) {
if (trim > 0) {
stop("trimmed means are not implemented for sparse_numeric")
}
total_sum <- sum(x@value, na.rm = na.rm)
total_sum / as.numeric(x@length)
})
# norm() method
#'  Norm of Sparse Numeric Vector
#'
#' Computes norm of sparse vector
#'
#'
#' @param x A sparse_numeric object
#' @param ... Additional arguments (not used)
#' @return The Euclidean norm of the vector
#' @export
#' @examples
#' x <- as(c(0, 3, 0, 4), "sparse_numeric")
#' norm(x)  # Returns 5
setGeneric("norm", function(x, ...) standardGeneric("norm"))
#' @rdname norm
#' @export
setMethod("norm", "sparse_numeric", function(x, ...) {
normsq = sum(x@value * x@value)
return(sqrt(normsq))
})
#' Standardize Sparse Numeric Vector
#'
#' Standardize sparse numeric vector, by subtracting mean and dividing by standard deviation.
#'
#'
#'
#' @param x A sparse_numeric object
#' @param na.rm logical, should missing values be removed?
#' @param ... Additional arguments (not used)
#' @return  standardized sparse_numeric object
#' @export
#' @examples
#' x <- as(c(0, 5, 0, -3, 0, 0, 10), "sparse_numeric")
#' x_std <- standardize(x)
setGeneric("standardize", function(x, ...) standardGeneric("standardize"))
#' @rdname standardize
#' @export
setMethod("standardize", "sparse_numeric", function(x, na.rm = FALSE, ...) {
n = as.numeric(x@length)
# sum and sum of squares over stored nonzeros
s  = sum(x@value, na.rm = na.rm)
ss = sum(x@value * x@value, na.rm = na.rm)
# mean
mu = s/n
# ss - s^2/n = sum((xi - mu)^2)
sqd = ss - (s * s)/n
# If variance is zero â†’ standardized vector is all zeros
if (isTRUE(all.equal(sqd, 0))) {
return(new("sparse_numeric",
value = numeric(0),
pos   = integer(0),
length = x@length))
}
sd_sample = sqrt(sqd / (n - 1))
# Standardize ALL positions (not just the stored ones)
# Convert to dense, standardize, convert back
dense_vec = as(x, "numeric")
standardized_dense = (dense_vec - mu) / sd_sample
# Convert back to sparse
return(as(standardized_dense, "sparse_numeric"))
})
document()]
document()
rm(list = c("mean", "norm", "sparse_add", "sparse_crossprod", "sparse_mult", "sparse_sub", "standardize"))
test()
document()
rm(list = c(plot))
rm(list = c("plot"))
test()
library(covr)
coverage = package_coverage()
coverage
test*()
test()
coverage = package_coverage()
coverage
check()
getwd()
check()
use_mit_license("Akash Rajeev")
check()
document()
check()
library(covr)
report()
library(covr)
report()
devtools::document()
devtools::load_all()
covr::report()
normalizePath("tests/testthat/test_sparse_numeric.R")
getwd()
normalizePath("tests/testthat/test_sparse_numeric.R")
list.files(".", recursive = TRUE)
list.files("tests", recursive = TRUE)
getwd()
library(usethis)
use_readme_rmd()
library(Homework6)
# Create a regular numeric vector
regular_vec = c(0, 1.5, 0, 0, 2.3, 0, 0, 4.1, 0, 0)
# Convert to sparse format
sparse_vec = as(regular_vec, "sparse_numeric")
print(sparse_vec)
# Create another sparse vector
regular_vec2 = c(0, 0.5, 0, 1.0, 2.3, 0, 0, 0, 3.2, 0)
sparse_vec2 = as(regular_vec2, "sparse_numeric")
# Arithmetic operations
sum_vec = sparse_vec + sparse_vec2
print(sum_vec)
diff_vec = sparse_vec - sparse_vec2
print(diff_vec)
product_vec = sparse_vec * sparse_vec2
print(product_vec)
# Dot product
dot_result = sparse_crossprod(sparse_vec, sparse_vec2)
print(dot_result)
devtools::build_readme()
install.packages("pkgdown")
install.packages("pkgdown")
library(pkgdown)
usethis::use_pkgdown()
getwd()
pkgdown::build_site()
devtools::check()
# Update documentation from roxygen2 comments
devtools::document()
# Check that all exported functions have documentation
?mean.sparse_numeric
?norm
?standardize
# etc. for all your exported funct
devtools::test()
covr::package_coverage()
devtools::build_readme()
devtools::check()
covr::package_coverage()
pkgdown::build_site()
usethis::use_github_action("check-standard")
git add .
git add .
check()
usethis::use_github_action("pkgdown")
git add .github/workflows/pkgdown.yaml
library(Homework6)
# Create a regular numeric vector
regular_vec = c(0, 1.5, 0, 0, 2.3, 0, 0, 4.1, 0, 0)
# Convert to sparse format
sparse_vec = as(regular_vec, "sparse_numeric")
print(sparse_vec)
# Create another sparse vector
regular_vec2 = c(0, 0.5, 0, 1.0, 2.3, 0, 0, 0, 3.2, 0)
sparse_vec2 = as(regular_vec2, "sparse_numeric")
# Arithmetic operations
sum_vec = sparse_vec + sparse_vec2
diff_vec = sparse_vec - sparse_vec2
product_vec = sparse_vec * sparse_vec2
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%",
warning=FALSE,
message=FALSE
)
devtools::build_readme()
devtools::build_readme()
pkgdown::build_site()
